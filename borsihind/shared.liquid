{% template pricelist %}
<table class="table table--condensed">
  <tbody>
    <tr>
      <td><span class="label label--small" id="electricity-price-label">Elektri hind</span></td>
      <td class="text--right"><span class="label label--small" id="current-electricity-price"></span></td>
    </tr>
    <tr>
      <td><span class="label label--small" id="transmission-cost-label">Edastamise tasu</span></td>
      <td class="text--right"><span class="label label--small" id="current-transmission-cost"></span></td>
    </tr>
    <tr>
      <td><span class="label label--small" id="state-fees-label">Riigi maksud</span></td>
      <td class="text--right"><span class="label label--small" id="current-state-fees"></span></td>
    </tr>
    <tr>
      <td><span class="label label--small" id="margin-label">Müüja marginaal</span></td>
      <td class="text--right"><span class="label label--small" id="current-margin"></span></td>
    </tr>
  </tbody>
</table>
{% endtemplate %}

{% template timespan %}
<div class="w--full flex flex--row flex--top pt--1 px--3" id="cheapest-{{ hours }}h-container">
  <div class="label label--small label--inverted px--2">{{ hours }}h</div>
  <div class="stretch">
    <div class="w--full flex flex--row">
      <span class="title title--small" id="cheapest-{{ hours }}h-start"></span>
      <span class="title title--small text--center stretch">-</span>
      <span class="title title--small" id="cheapest-{{ hours }}h-end"></span>
    </div>
    <div class="flex flex--row">
      <span class="label label--small stretch" id="cheapest-{{ hours }}h-value"></span>
      <span class="label label--small" id="cheapest-{{ hours }}h-diff"></span>
    </div>
  </div>
</div>
{% endtemplate %}

<script src='https://code.highcharts.com/highcharts.js'></script>
<script src='https://code.highcharts.com/modules/pattern-fill.js'></script>

<script>
  document.addEventListener('DOMContentLoaded', function() {
    // Translation definitions
    const translations = {
      electricityPrice: {
        et: 'Elektri hind',
        en: 'Electricity price'
      },
      transmissionCost: {
        et: 'Edastamise tasu',
        en: 'Transmission cost'
      },
      stateFees: {
        et: 'Riigi maksud',
        en: 'State taxes'
      },
      margin: {
        et: 'Müüja marginaal',
        en: 'Seller margin'
      },
      cheapHours: {
        et: 'Odavad tunnid',
        en: 'Cheap hours'
      }
    }

    const language = '{{ trmnl.plugin_settings.custom_fields_values.language }}' || 'et'

    // Update translation labels
    const electricityPriceLabelEl = document.getElementById('electricity-price-label')
    if (electricityPriceLabelEl) electricityPriceLabelEl.textContent = translations.electricityPrice[language]

    const transmissionCostLabelEl = document.getElementById('transmission-cost-label')
    if (transmissionCostLabelEl) transmissionCostLabelEl.textContent = translations.transmissionCost[language]

    const stateFeesLabelEl = document.getElementById('state-fees-label')
    if (stateFeesLabelEl) stateFeesLabelEl.textContent = translations.stateFees[language]

    const marginLabelEl = document.getElementById('margin-label')
    if (marginLabelEl) marginLabelEl.textContent = translations.margin[language]

    // Update cheap hours title
    const cheapHoursTitleEl = document.getElementById('cheap-hours-title')
    if (cheapHoursTitleEl) cheapHoursTitleEl.textContent = translations.cheapHours[language]

    // Data format: [year, month, day, hour, minute, electricity_price, transmission_cost, renewable_energy_fee, equipment_insurance_fee, electricity_excise]
    // Load only the data we need based on interval setting - IDX_0 = 1h intervals, IDX_1 = 15min intervals
    const hourlyData = {{ IDX_0 | json }}
    const quarterHourlyData = {{ IDX_1 | json }}
    const selectedTimespan = '{{ trmnl.plugin_settings.custom_fields_values.timespan }}'
    const interval = parseInt('{{ trmnl.plugin_settings.custom_fields_values.interval }}') || 15
    const margin = (parseFloat('{{ trmnl.plugin_settings.custom_fields_values.margin }}'.replace(',', '.')) || 0) / 100
    let rawData = interval === 60 ? hourlyData.data : quarterHourlyData.data

    // Filter out old data - keep only from current time rounded to interval
    const now = new Date()
    const currentActualHour = now.getHours()
    const currentActualMinute = now.getMinutes()
    
    // Round down to nearest interval
    let roundedMinute
    if (interval === 60) {
      roundedMinute = 0
    } else {
      // Round down to nearest 15-minute interval (0, 15, 30, 45)
      roundedMinute = Math.floor(currentActualMinute / 15) * 15
    }
    
    // Filter rawData to keep only entries from the rounded current time forward
    // Compare full datetime to handle midnight crossover correctly
    const currentDate = new Date(now.getFullYear(), now.getMonth(), now.getDate(), currentActualHour, roundedMinute)
    
    rawData = rawData.filter(row => {
      const rowDate = new Date(row[0], row[1] - 1, row[2], row[3], row[4]) // year, month (0-indexed), day, hour, minute
      return rowDate >= currentDate
    })

    // Data structure mapping for better maintainability
    const DATA_FIELDS = {
      year: 0,
      month: 1,
      day: 2,
      hour: 3,
      minute: 4,
      electricityPrice: 5,
      transmissionCost: 6,
      renewableEnergyFee: 7,
      equipmentInsuranceFee: 8,
      electricityExcise: 9
    }

    // Metric configuration with data field mapping
    const METRICS = [
      { key: 'electricityPrice', label: translations.electricityPrice[language], field: DATA_FIELDS.electricityPrice },
      { key: 'transmissionCost', label: translations.transmissionCost[language], field: DATA_FIELDS.transmissionCost },
      { key: 'stateFees', label: translations.stateFees[language], fields: [DATA_FIELDS.renewableEnergyFee, DATA_FIELDS.equipmentInsuranceFee, DATA_FIELDS.electricityExcise] },
      { key: 'margin', label: translations.margin[language], value: margin }
    ]

    // Find the lowest total cost time span of specified duration
    function findLowestTimeSpan(prices, span, dataToUse) {
      if (prices.length === 0) return { price: 0, start: '00:00', end: '01:00' }

      // Calculate total price for each time slot (without margin, it's added to display later)
      const pricesSum = prices.map((x) =>
        x[DATA_FIELDS.electricityPrice] +
        x[DATA_FIELDS.transmissionCost] +
        x[DATA_FIELDS.renewableEnergyFee] +
        x[DATA_FIELDS.equipmentInsuranceFee] +
        x[DATA_FIELDS.electricityExcise]
      )

      let lowestSum = Infinity
      let lowestSumIndex = -1

      for (let i = 0; i < pricesSum.length - span + 1; i++) {
        const sum = pricesSum.slice(i, i + span).reduce((acc, val) => acc + val, 0)

        // Use < (not <=) to keep the earliest period when multiple periods have the same price
        // Round to 4 decimal places to avoid floating-point precision issues
        const roundedSum = Math.round(sum * 10000) / 10000
        const roundedLowest = Math.round(lowestSum * 10000) / 10000

        if (roundedSum < roundedLowest) {
          lowestSum = sum
          lowestSumIndex = i
        }
      }

      const startHour = dataToUse[lowestSumIndex][DATA_FIELDS.hour]
      const startMinute = dataToUse[lowestSumIndex][DATA_FIELDS.minute]

      // Calculate end time based on interval setting
      const minutesPerSlot = interval === 60 ? 60 : 15
      const totalMinutes = span * minutesPerSlot
      const endDate = new Date()
      endDate.setHours(startHour, startMinute + totalMinutes, 0, 0)
      const endHour = endDate.getHours()
      const endMinute = endDate.getMinutes()

      return {
        start: `${startHour.toString().padStart(2, '0')}:${startMinute.toString().padStart(2, '0')}`,
        end: `${endHour.toString().padStart(2, '0')}:${endMinute.toString().padStart(2, '0')}`,
        price: (lowestSum / span + margin) * 100 // Average price per slot + margin, convert to cents
      }
    }

    // Calculate current total price (first row total in cents)
    const firstRowValues = rawData[0]

    // Get current time for display and calculations
    const currentHour = firstRowValues[DATA_FIELDS.hour].toString().padStart(2, '0')
    const currentMinute = firstRowValues[DATA_FIELDS.minute] // Use minute from data instead of actual current minute
    const currentTime = `${currentHour}:${currentMinute.toString().padStart(2, '0')}`

    // Calculate end time based on interval setting
    const minutesPerSlot = interval === 60 ? 60 : 15
    const endMinute = (currentMinute + minutesPerSlot) % 60
    const endHour = (firstRowValues[DATA_FIELDS.hour] + Math.floor((currentMinute + minutesPerSlot) / 60)).toString().padStart(2, '0')
    const endTime = `${endHour}:${endMinute.toString().padStart(2, '0')}`

    // Current price being charged right now (this very moment)
    const currentPrice = (
      firstRowValues[DATA_FIELDS.electricityPrice] +
      firstRowValues[DATA_FIELDS.transmissionCost] +
      firstRowValues[DATA_FIELDS.renewableEnergyFee] +
      firstRowValues[DATA_FIELDS.equipmentInsuranceFee] +
      firstRowValues[DATA_FIELDS.electricityExcise] +
      margin
    ) * 100

    // Calculate cheapest periods
    // For 15min interval: 1h = 4 slots, 2h = 8 slots, etc.
    // For 60min interval: 1h = 1 slot, 2h = 2 slots, etc.
    const slotsPerHour = interval === 60 ? 1 : 4
    const cheapest1h = findLowestTimeSpan(rawData, 1 * slotsPerHour, rawData)
    const cheapest2h = findLowestTimeSpan(rawData, 2 * slotsPerHour, rawData)
    const cheapest3h = findLowestTimeSpan(rawData, 3 * slotsPerHour, rawData)
    const cheapest4h = findLowestTimeSpan(rawData, 4 * slotsPerHour, rawData)

    // Update the displayed values
    const displayItems = [
      {
        value: currentPrice.toFixed(2),
        label: `${currentHour}:${currentMinute.toString().padStart(2, '0')} – ${endHour}:${endMinute.toString().padStart(2, '0')}`,
        startTime: `${currentHour}:${currentMinute.toString().padStart(2, '0')}`,
        endTime: `${endHour}:${endMinute.toString().padStart(2, '0')}`,
        difference: null // Current price has no difference to itself
      },
      {
        value: cheapest1h.price.toFixed(2),
        label: `${cheapest1h.start} – ${cheapest1h.end}`,
        startTime: cheapest1h.start,
        endTime: cheapest1h.end,
        difference: Math.round((currentPrice - cheapest1h.price) / currentPrice * 100) // Percentage difference (rounded)
      },
      {
        value: cheapest2h.price.toFixed(2),
        label: `${cheapest2h.start} – ${cheapest2h.end}`,
        startTime: cheapest2h.start,
        endTime: cheapest2h.end,
        difference: Math.round((currentPrice - cheapest2h.price) / currentPrice * 100) // Percentage difference (rounded)
      },
      {
        value: cheapest3h.price.toFixed(2),
        label: `${cheapest3h.start} – ${cheapest3h.end}`,
        startTime: cheapest3h.start,
        endTime: cheapest3h.end,
        difference: Math.round((currentPrice - cheapest3h.price) / currentPrice * 100) // Percentage difference (rounded)
      },
      {
        value: cheapest4h.price.toFixed(2),
        label: `${cheapest4h.start} – ${cheapest4h.end}`,
        startTime: cheapest4h.start,
        endTime: cheapest4h.end,
        difference: Math.round((currentPrice - cheapest4h.price) / currentPrice * 100) // Percentage difference (rounded)
      }
    ]

    // Update displayed price values
    const currentValueEl = document.getElementById('current-value')
    if (currentValueEl) currentValueEl.textContent = displayItems[0].value

    const cheapest1hValueEl = document.getElementById('cheapest-1h-value')
    if (cheapest1hValueEl) cheapest1hValueEl.textContent = displayItems[1].value

    const cheapest2hValueEl = document.getElementById('cheapest-2h-value')
    if (cheapest2hValueEl) cheapest2hValueEl.textContent = displayItems[2].value

    const cheapest3hValueEl = document.getElementById('cheapest-3h-value')
    if (cheapest3hValueEl) cheapest3hValueEl.textContent = displayItems[3].value

    const cheapest4hValueEl = document.getElementById('cheapest-4h-value')
    if (cheapest4hValueEl) cheapest4hValueEl.textContent = displayItems[4].value

    // Update price difference displays (savings compared to current price as percentage)
    const cheapest1hDiffEl = document.getElementById('cheapest-1h-diff')
    if (cheapest1hDiffEl) cheapest1hDiffEl.textContent = displayItems[1].difference > 0 ? `-${displayItems[1].difference}%` : `${displayItems[1].difference}%`

    const cheapest2hDiffEl = document.getElementById('cheapest-2h-diff')
    if (cheapest2hDiffEl) cheapest2hDiffEl.textContent = displayItems[2].difference > 0 ? `-${displayItems[2].difference}%` : `${displayItems[2].difference}%`

    const cheapest3hDiffEl = document.getElementById('cheapest-3h-diff')
    if (cheapest3hDiffEl) cheapest3hDiffEl.textContent = displayItems[3].difference > 0 ? `-${displayItems[3].difference}%` : `${displayItems[3].difference}%`

    const cheapest4hDiffEl = document.getElementById('cheapest-4h-diff')
    if (cheapest4hDiffEl) cheapest4hDiffEl.textContent = displayItems[4].difference > 0 ? `-${displayItems[4].difference}%` : `${displayItems[4].difference}%`

    // Update displayed time labels with justified layout
    const currentTimeEl = document.getElementById('current-time')
    if (currentTimeEl) currentTimeEl.textContent = displayItems[0].label

    const cheapest1hStartEl = document.getElementById('cheapest-1h-start')
    const cheapest1hEndEl = document.getElementById('cheapest-1h-end')
    if (cheapest1hStartEl && cheapest1hEndEl) {
      cheapest1hStartEl.textContent = displayItems[1].startTime
      cheapest1hEndEl.textContent = displayItems[1].endTime
    }

    const cheapest2hStartEl = document.getElementById('cheapest-2h-start')
    const cheapest2hEndEl = document.getElementById('cheapest-2h-end')
    if (cheapest2hStartEl && cheapest2hEndEl) {
      cheapest2hStartEl.textContent = displayItems[2].startTime
      cheapest2hEndEl.textContent = displayItems[2].endTime
    }

    const cheapest3hStartEl = document.getElementById('cheapest-3h-start')
    const cheapest3hEndEl = document.getElementById('cheapest-3h-end')
    if (cheapest3hStartEl && cheapest3hEndEl) {
      cheapest3hStartEl.textContent = displayItems[3].startTime
      cheapest3hEndEl.textContent = displayItems[3].endTime
    }

    const cheapest4hStartEl = document.getElementById('cheapest-4h-start')
    const cheapest4hEndEl = document.getElementById('cheapest-4h-end')
    if (cheapest4hStartEl && cheapest4hEndEl) {
      cheapest4hStartEl.textContent = displayItems[4].startTime
      cheapest4hEndEl.textContent = displayItems[4].endTime
    }

    // Remove existing selection classes
    const timespanContainers = ['cheapest-1h-container', 'cheapest-2h-container', 'cheapest-3h-container', 'cheapest-4h-container']
    timespanContainers.forEach(containerId => {
      const container = document.getElementById(containerId)
      if (container) {
        container.classList.remove('timespan-selected')
      }
    })

    // Add selection class to the chosen timespan (only if one is selected)
    if (selectedTimespan) {
      const selectedContainer = document.getElementById(`cheapest-${selectedTimespan}h-container`)
      if (selectedContainer) selectedContainer.classList.add('timespan-selected')
    }

    // Update current price component breakdown (convert to cents)
    const currentElectricityPriceEl = document.getElementById('current-electricity-price')
    if (currentElectricityPriceEl) currentElectricityPriceEl.textContent = (firstRowValues[DATA_FIELDS.electricityPrice] * 100).toFixed(2)

    const currentTransmissionCostEl = document.getElementById('current-transmission-cost')
    if (currentTransmissionCostEl) currentTransmissionCostEl.textContent = (firstRowValues[DATA_FIELDS.transmissionCost] * 100).toFixed(2)

    const currentStateFeesEl = document.getElementById('current-state-fees')
    if (currentStateFeesEl) {
      const stateFees = (firstRowValues[DATA_FIELDS.renewableEnergyFee] +
                         firstRowValues[DATA_FIELDS.equipmentInsuranceFee] +
                         firstRowValues[DATA_FIELDS.electricityExcise]) * 100
      currentStateFeesEl.textContent = stateFees.toFixed(2)
    }

    const currentMarginEl = document.getElementById('current-margin')
    if (currentMarginEl) currentMarginEl.textContent = (margin * 100).toFixed(3)

    // Prepare chart data
    let chartData = rawData
    let categories = []

    if (interval === 60) {
      categories = chartData.map(x => {
        const hour = x[DATA_FIELDS.hour].toString().padStart(2, '0')
        return hour
      })
    } else {
      // Use 15-minute intervals - show all times but only label full hours
      categories = chartData.map(x => {
        const hour = x[DATA_FIELDS.hour].toString().padStart(2, '0')
        const minute = x[DATA_FIELDS.minute].toString().padStart(2, '0')
        // Show full time for all, but we'll style only hours in xAxis formatter
        return `${hour}:${minute}`
      })
    }

    // Transform data into chart series format (convert to cents)
    const formattedBarData = METRICS.map(metric => {
      if (metric.fields) {
        // Combined metric - sum multiple fields
        return {
          name: metric.label,
          data: chartData.map(x => metric.fields.reduce((sum, field) => sum + x[field], 0) * 100)
        }
      }
      return {
        name: metric.label,
        data: chartData.map(x => (metric.value || x[metric.field]) * 100)
      }
    })

    // Initialize Highcharts chart (spline for 15min, stacked column for 60min)
    Highcharts.chart('example-bar-chart', {
      accessibility: {
        enabled: false
      },
      chart: {
        type: interval === 15 ? 'areaspline' : 'column',
        height: null,
        width: null,
        animation: false,
        spacing: [5, 5, 5, 5]
      },
      title: {
        text: null
      },
      plotOptions: {
        series: {
          animation: false,
          enableMouseTracking: false,
          states: {
            hover: { enabled: false }
          },
          pointPadding: 0.05,
          groupPadding: 0.1,
          borderWidth: 0,
          stacking: 'normal'
        },
        column: {
          pointPadding: 0.05,
          groupPadding: 0.1,
          borderWidth: 0,
          borderRadius: 0
        },
        areaspline: {
          lineWidth: 1,
          marker: {
            enabled: false
          }
        }
      },
      // Data series with distinct visual styles for each metric
      series: [{
        data: formattedBarData[0].data,
        name: formattedBarData[0].name,
        color: '#000000'
      }, {
        data: formattedBarData[1].data,
        name: formattedBarData[1].name,
        color: {
          pattern: {
            image: 'https://usetrmnl.com/images/grayscale/gray-2.png',
            width: 12,
            height: 12
          }
        }
      }, {
        data: formattedBarData[2].data,
        name: formattedBarData[2].name,
        color: {
          pattern: {
            image: 'https://usetrmnl.com/images/grayscale/gray-3.png',
            width: 12,
            height: 12
          }
        }
      }, {
        data: formattedBarData[3].data,
        name: formattedBarData[3].name,
        color: {
          pattern: {
            image: 'https://usetrmnl.com/images/grayscale/gray-4.png',
            width: 12,
            height: 12
          }
        }
      }],
      tooltip: { enabled: false },
      legend: { enabled: false },
      yAxis: {
        labels: {
          style: { fontSize: '16px', color: '#000000' },
          x: -10
        },
        gridLineDashStyle: 'shortdot',
        gridLineWidth: 1,
        gridLineColor: '#000000',
        title: {
          text: null
        }
      },
      xAxis: {
        categories: categories,
        labels: {
          style: { fontSize: '16px', color: '#000000' },
          y: 20,
          rotation: 0,
          align: 'center',
          step: interval === 15 ? 4 : 1,
          formatter: function() {
            // For 15min interval, extract just the hour from HH:MM format
            if (interval === 15 && this.value && this.value.includes(':')) {
              return this.value.split(':')[0]
            }
            return this.value
          }
        },
        gridLineDashStyle: 'dot',
        gridLineColor: '#000000',
        title: {
          text: null
        }
      },
      credits: {
        enabled: false
      }
    })
  })
</script>

<style>
  .label--inverted {
    border-radius: 0 !important;
    height: 22px !important;
    line-height: 1.25rem !important;
  }
  .timespan-selected {
    border: 1px dotted #000000 !important;
    border-radius: 0 !important;
  }
</style>
